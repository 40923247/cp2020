var tipuesearch = {"pages": [{'title': '首頁', 'text': 'HI HI HI \n', 'tags': '', 'url': '首頁.html'}, {'title': 'HW1', 'text': '', 'tags': '', 'url': 'HW1.html'}, {'title': 'U13', 'text': '', 'tags': '', 'url': 'U13.html'}, {'title': 'IPv4 and IPv6 Addresses', 'text': 'Overview \n In this lesson, we will discuss TCP/IP, and the two common types of Internet addressing: Internet protocol version 4 (IPv4) and Internet protocol version 6 (IPv6). We will discuss IPv4 in depth, as it is still the most dominant version in use in our networks. Then, we will cover the specifics of IPv6, differences between IPv4 and IPv6, and the reason we are moving toward IPv6 in the future. \n 總覽 \n 在本課程中，我們將討論TCP / IP以及Internet尋址的兩種常見類型：Internet協議版本4（IPv4）和Internet協議版本6（IPv6）。 我們將深入討論IPv4，因為它仍然是我們網絡中使用的最主要版本。 然後，我們將介紹IPv6的細節，IPv4與IPv6之間的差異以及未來轉向IPv6的原因。 \n TCP/IP \n Computer networks — including the Internet, which is the largest computer network — use Transmission Control Protocol/Internet Protocol or TCP/IP for network communications both internally on a LAN/WAN and externally to the Internet. \n TCP/IP provides end-to-end connectivity of data. TCP/IP specifies how data should be grouped, addressed, transmitted, routed, and received at the destination address. The TCP/IP model, along with many of its protocols, is maintained and managed by the IETF (Internet Engineering Task Force). \n TCP/IP is one of two sets of protocols that collectively operate in the transport and network layers of the OSI model. \n 計算機網路（包括作為最大計算機網路的Internet）使用傳輸控制協議/ Internet協議或TCP / IP進行內部LAN / WAN上和外部Internet的網路通信。 \n TCP / IP提供數據的端到端連接。 TCP / IP指定如何在目標地址處對數據進行分組，尋址，傳輸，路由和接收。 TCP / IP模型及其許多協議由IETF（Internet工程任務組）維護和管理。 \n TCP / IP是在OSI模型的傳輸層和網絡層中共同運行的兩組協議之一。 \n \n \n OSI Model. Image used under CC-BY-SA license from\xa0 Wikimedia Commons . \n In addition to creating message segments and ensuring connectivity, some of the basic characteristics of the IP protocol ensure that datagrams are routed to the correct destination using a binary addressing scheme. While the process of how the IP addresses are derived from binary (and hexadecimal relationships) is not covered in this course, it is important to know that just as computer CPUs use binary numbers to process data, networking hardware and protocols do so as well. \n 除了創建訊息段並確保連接性之外，IP協議的某些基本特徵還可以確保使用二進制尋址找方案將數據路由到正確的目的地。 儘管本課程未涵蓋如何從二進制（和十六進制關係）派生IP地址的過程，但重要的是要知道，就像計算機CPU使用二進制數來處理數據一樣，網絡硬體和網路傳輸協定也是如此。 \n IPv4 and IPv6 Addresses \n Network devices require a logical address — either an IPv4 or IPv6 address (see the network layer in the diagram above) — when moving data from one network segment to another. As we discussed in previous modules, switches make their intelligent switching decisions (see the data link layer in the diagram above based on media access control (MAC) addresses. The MAC address, also known as the physical address, is the unique identifier hard coded on a network interface card by the manufacturer. Switches use these MAC addresses to identify which devices are on which switch ports, and forward traffic within the network segment to the correct ports based on these addresses. When data traffic needs to cross the boundaries of the network, it requires a logical address that the router can use to make intelligent routing decisions. In most modern networks, this is done by using TCP/IP addressing. Historically, other protocols existed, such as internetwork packet exchange/sequenced packet exchange (IPX/SPX) for Novell networks, AppleTalk, and NetBEUI for Microsoft networks. TCP/IP replaced these protocols almost exclusively due to its robust nature, reliability, and availability. \n \xa0 \n While the majority of our networks today still use IPv4, many networks are migrating to the newer IPv6 addressing standards. Additionally, many networks are offering dual support to both IPv4 and IPv6 during the transition. The reason for this transition is that we were running out of valid IPv4 addresses. IPv4 uses a 32-bit addressing scheme, providing only 4.2 billion available addresses, but IPv6 uses a 128-bit addressing scheme. IPv6 allows for 2128addresses, or 340,282,366,920,938,000,000,000,000,000,000,000,000 (3.4 x 1038) unique IP addresses. IPv6 allows for more IP addresses than humanity could ever utilize. At least that is what we think right now. \n \xa0 \n IPv4 和 IPv6 地址 \n 將數據從一個網段移動到另一個網段時，網絡設備需要邏輯地址 -IPv4 或 IPv6 地址（請參見上圖中的網絡層）。正如我們在之前的模塊中討論的那樣，交換機做出明智的交換決策（請參見上圖中的數據鏈路層，基於媒體訪問控制（ MAC ）地址。 MAC 地址，也稱為物理地址，是唯一的硬編碼標識符）交換機使用這些 MAC 地址來識別哪些設備在哪個交換機端口上，然後根據這些地址將網段內的流量轉發到正確的端口。在網絡中，它需要路由器可以用來做出智能路由決定的邏輯地址。在大多數現代網絡中，這是通過使用 TCP / IP 尋址來完成的。  / SPX ）（用於 Novell 網絡）， AppleTalk 和用於 Microsoft 網絡的 NetBEUI 。 TCP/ IP 幾乎完全由於其魯棒性，可靠性和可用性而取代了這些協議。不可靠。 \n \xa0 \n 儘管當今我們的大多數網絡仍使用 IPv4 ，但許多網絡正在遷移到更新的 IPv6 尋址標準。此外，在過渡期間，許多網絡都對 IPv4 和 IPv6 提供雙重支持。進行此轉換的原因是我們用盡了有效的 IPv4 地址。  IPv4 使用 32 位尋址方案，僅提供 42 億個可用地址，而 IPv6 使用 128 位尋址方案。  IPv6 允許 2128 個地址或 340,282,366,920,938,000,000,000,000,000,000,000,000,000,000 （ 3.4 x 1038 ）個唯一 IP 地址。  IPv6 所允許的 IP 地址比人類所能利用的更多。至少這就是我們現在的想法。 \n', 'tags': '', 'url': 'IPv4 and IPv6 Addresses.html'}, {'title': 'IPv4 Addressing', 'text': 'IPv4 尋址 \n Addressing Notation \n 尋址符號 \n Internet protocol (IP) networking relies on both an IP address and subnet mask using a 32-bit dotted decimal notation. The Internet Engineering Task Force (IETF) and the Internet Corporation for Assigned Names and Numbers (ICANN) developed and maintains the standards for IP allocation and protocols. \n \xa0 \n While the following IP address and subnet mask looks like a regular decimal number separated by periods: \n Internet 協議（ IP ）網絡使用 32 位點分十進製表示法同時依賴 IP 地址和子網掩碼。 互聯網工程任務組（ IETF ）和互聯網名稱與數字地址分配機構（ ICANN ）制定並維護了 IP 分配和協議的標準。 \n \xa0 \n 以下 IP 地址和子網掩碼看起來像是一個普通的十進制數字，中間用句點分隔： \n \n \n \n \n 1 \n \n \n 168.1.1 \n \n \n \n \n \xa0 \n \n \n \n \n 2 \n \n \n 255.255.255.0 \n \n \n \n \n The computer sees the binary: \n 計算機看到二進製文件： \n \n \n \n \n 1 \n \n \n 11000000.10101000.00000001.00000001 \n \n \n \n \n \xa0 \n \n \n \n \n 2 \n \n \n 11111111.11111111.11111111.00000000 \n \n \n \n \n Each octet is made up of eight bits (one byte or two nibbles); multiplied by four octets, that equals 32 bits. The maximum value for any octet is 255 (28-1) so therefore the maximum number of IPv4 addresses available is 232, which equals 4,294,967,296 unique addresses. \n \xa0 \n The presence of the subnet mask tells networking devices how much of the IP address belongs to the network and how much to the host. The 255.255.255.0 subnet represents that the first three octets are the network and the “0” represents the available number of hosts (nodes). So, the form is N.N.N.H. Think of the combination of IP and subnet as similar to regular postal addresses. You need a zip code (subnet) and street address (host). \n \xa0 \n There are five different classes in IPv4 labelled A through E, with classes A, B, and C used by computer networks and classes D and E reserved as experimental. As originally designed, the IP range is determined by the lead bits in the first octet and matched to one specific subnet mask. This is called "classful" addressing. When the IP class does not match the default subnet mask, it is called "classless." \n 每個八位位組由八位組成（一個字節或兩個半字節）。乘以四個八位位組，等於 32 位。任何八位位組的最大值為 255 （ 28-1 ），因此，可用的 IPv4 地址的最大數量為 232 ，等於 4,294,967,296 個唯一地址。 \n \xa0 \n 子網掩碼的存在告訴網絡設備多少 IP 地址屬於網絡，多少屬於主機。  255.255.255.0 子網表示前三個八位位組是網絡，“  0 ”表示可用的主機（節點）數。因此，表格為 N.N.N.H. 可以將 IP 和子網的組合視為類似於常規郵政地址。您需要一個郵政編碼（子網）和街道地址（主機）。 \n \xa0 \n IPv4中有五種不同的類別，標記為 A 到 E ，計算機網絡使用的類別為 A ， B 和 C ， D 和 E 類別保留為實驗性。按照最初的設計， IP 範圍由第一個八位位組中的前導位確定，並與一個特定的子網掩碼匹配。這稱為“有類”尋址。如果 IP 類與默認子網掩碼不匹配，則稱為“無類”。 \n \xa0 \n Network and Host Addresses \n 網絡和主機地址 \n \xa0 \n An IPv4 network address is further divided into two portions based upon the subnet mask: the network portion and the host portion. A subnet mask is a series of numbers used for routing traffic within a subnetwork. When a subnet mask is used to define the network portion, anywhere there is a binary “11111111” (or 255 in decimal) used, this area is considered part of the network portion. When a binary “00000000” (0 in decimal) is used, this represents the host portion of the address. The host represents a single device on the network, such as your computer or phone. \n \xa0 \n The following two tables show the network and host portions of IP addresses. \n IPv4網絡地址根據子網掩碼進一步分為兩部分：網絡部分和主機部分。 子網掩碼是用於在子網內路由流量的一系列數字。 當使用子網掩碼定義網絡部分時，在任何使用二進制“  11111111 ”（或十進制 255 ）的地方，該區域均被視為網絡部分的一部分。 當使用二進制“  00000000 ”（十進制為 0 ）時，它表示地址的主機部分。 主機代表網絡上的單個設備，例如您的計算機或電話。 \n \xa0 \n 以下兩個表顯示了 IP 地址的網絡部分和主機部分。 \n \n \n \n \n IP address (in decimal) \n \n \n 10 \n \n \n 1 \n \n \n 2 \n \n \n 3 \n \n \n \n \n IP address (in binary) \n \n \n 00001010 \n \n \n 00000001 \n \n \n 00000010 \n \n \n 00000011 \n \n \n \n \n Subnet mask (in decimal) \n \n \n 255 \n \n \n 0 \n \n \n 0 \n \n \n 0 \n \n \n \n \n Subnet mask (in binary) \n \n \n 11111111 \n \n \n 00000000 \n \n \n 00000000 \n \n \n 00000000 \n \n \n \n \n \n Network bits \n \n \n Host bits \n \n \n Host bits \n \n \n Host bits \n \n \n \n \n \n In the example above, we see that our IP address is 10.1.2.3, and it has a class A subnet mask of 255.0.0.0. (We will discuss subnet classes in more detail later in this module). If this subnet mask is converted to binary, we see is written as eight 1s, followed by 24 0s, giving us 255.0.0.0 in decimal notation. Therefore, wherever we see a 255 in a subnet mask, we know we are seeing the network portion defined. So, for this example, our specific host is 10.1.2.3 and our network address would be 10.0.0.0. \n 在上面的示例中，我們看到我們的 IP 地址為 10.1.2.3 ，它的 A 類子網掩碼為 255.0.0.0 。 （在本模塊的後面，我們將更詳細地討論子網類）。 如果將此子網掩碼轉換為二進制，我們將看到它寫成八個 1 ，然後是 24 0 ，十進製表示為 255.0.0.0 。 因此，無論何時在子網掩碼中看到 255 ，我們都知道看到了定義的網絡部分。 因此，對於此示例，我們的特定主機為 10.1.2.3 ，我們的網絡地址為 10.0.0.0 。 \n \xa0 \n If a network has an IP address of 192.168.1.2, and the subnet mask of 255.255.255.0, we can identify the network and host portions of both addresses. To determine the network portion of the IP address, examine the subnet mask for which octets hold the value 255. In this case, the subnet mask has 255 in the first, second, and third octet. This means that the network portion of the IP address is the first, second, and third octet, as shown in the chart below. The remaining octet (the fourth octet) is the host portion of the address. \n \n \n \n \n \n Network Portion \n \n \n Host Portion \n \n \n \n \n IP Address: 192.168.1.2 \n \n \n 192.168.1 \n \n \n 2 \n \n \n \n \n Subnet Mask: 255.255.255.0 \n \n \n 255.255.255 \n \n \n 0 \n \n \n \n \n', 'tags': '', 'url': 'IPv4 Addressing.html'}, {'title': 'IPv4 Address Classes', 'text': 'IPv4 地址類別 \n As you can see, when the subnet mask has a 255 in it, it is defining the network portion of the address. In class A addresses, the first octet defines the network, and the last three define the host. In class B addresses, the first two octets define the network, the last two define the host. In class C addresses, the first three octets define the network, the last one defines the host. \n 如您所見，當子網掩碼中包含 255 時，它定義了地址的網絡部分。 在 A 類地址中，第一個八位位組定義網絡，最後三個八位位組定義主機。 在 B 類地址中，前兩個八位位組定義網絡，後兩個定義主機。 在 C 類地址中，前三個八位位組定義網絡，最後一個八位位組定義主機。 \n \n Subnet class table. Image used under CC-BY license from Jason Dion. \n \xa0 \n Subnet masks are used to define the specific network we are referencing. A standard class A subnet mask of 255.0.0.0 is used for all networks where the first octet starts with a number between 1 and 126. Recall from the subnet table below, our network was 10.0.0.0. \n 子網掩碼用於定義我們要引用的特定網絡。 255.0.0.0的標準A類子網掩碼適用於所有第一個八位位組以1到126之間的數字開頭的網絡。從下面的子網表中調用，我們的網絡為10.0.0.0。 \n \n \n \n \n IP address (in decimal) \n \n \n 10 \n \n \n 1 \n \n \n 2 \n \n \n 3 \n \n \n \n \n IP address (in binary) \n \n \n 00001010 \n \n \n 00000001 \n \n \n 00000010 \n \n \n 00000011 \n \n \n \n \n Subnet mask (in decimal) \n \n \n 255 \n \n \n 0 \n \n \n 0 \n \n \n 0 \n \n \n \n \n Subnet mask (in binary) \n \n \n 11111111 \n \n \n 00000000 \n \n \n 00000000 \n \n \n 00000000 \n \n \n \n \n \n Network bits \n \n \n Host bits \n \n \n Host bits \n \n \n Host bits \n \n \n \n \n Therefore, this address fits into the class A category. In this course, we only deal with “classful” subnet masks — the ones that only contain values of 255 and 0. In future courses, you may see other subnet masks used to further break apart the networks. \n 因此，該地址屬於 A 類類別。 在本課程中，我們僅處理“有類”子網掩碼 - 僅包含 255 和 0 的值。在以後的課程中，您可能會看到用於進一步拆分網絡的其他子網掩碼。 \n \n \n \n \n Address Class \n \n \n Value in First Octet \n \n \n Classful Mask (Dotted Decimal) \n \n \n Classful Mask (Prefix Notation) \n \n \n \n \n \n \n Class A \n \n \n 1 – 126 \n \n \n 255.0.0.0 \n \n \n /8 \n \n \n \n \n Class B \n \n \n 128 – 191 \n \n \n 255.255.0.0 \n \n \n /16 \n \n \n \n \n Class C \n \n \n 192 – 223 \n \n \n 255.255.255.0 \n \n \n /24 \n \n \n \n \n As you can see in the address classes table, class A references networks with the first octet having a value of 1-126, class B references 128-191, class C references 192-223. There is also a special address called the loopback address, which is 127.0.0.1. The entire range of 127.x.x.x is reserved to support this loopback address. A loopback address is an IP reserved to reference the computer on which you are currently working. Every computer knows to answer up for itself when a reference to 127.0.0.1 is given. This is also known as as the “localhost.” \n \xa0 \n To route your traffic over the Internet, you are required to have a publically routable IP address. These addresses are globally managed by the Internet Corporation for Assigned Names and Numbers (ICANN). If you desire to have one of these addresses, you must purchase them for use to ensure no one else has that specific number. For most users, this is done for you by your Internet service provider (ISP), but if you have a need for numerous public IP addresses, you can buy a block of them from ICANN. \n \xa0 \n Private IP addresses, on the other hand, can be used by anyone without any prior coordination. This is because private IP addresses are not routable over the Internet and are only used inside your local area network. For example, at your home, you may have five computers hooked up to your switch and those machines are all using private IP addresses. When you make a request to go outside the network, like to visit a college’s website, your router performs a network address translation (NAT) that allows your private IP address to be converted into a public IP address and a port, which then makes the request on your behalf. There is a specific range of IP addresses that are reserved as private for internal use (by you and others). \n 如您在地址類別表中看到的，類別 A 引用第一個八位位組的值是 1-126 的網絡，類別 B 引用 128-191 ，類別 C 引用 192-223 。還有一個稱為回送地址的特殊地址，即 127.0.0.1 。保留 127.x.x.x 的整個範圍以支持此回送地址。回送地址是保留的 IP ，用於引用您當前正在使用的計算機。當給出對 127.0.0.1 的引用時，每台計算機都知道會自己回答。這也稱為“本地主機”。 \n 要通過 Internet 路由流量，您需要具有可公共路由的 IP 地址。這些地址由互聯網名稱與數字地址分配機構（ ICANN ）全局管理。如果您希望擁有這些地址之一，則必須購買它們以確保沒有其他人擁有該特定號碼。對於大多數用戶而言，這是由 Internet 服務提供商（ ISP ）為您完成的，但是如果您需要大量的公共 IP 地址，則可以從 ICANN 購買其中的一部分。 \n \xa0 \n 另一方面，任何人都可以使用私有 IP 地址，而無需事先協調。這是因為專用 IP 地址無法通過 Internet 路由，而只能在局域網內使用。例如，在家裡，您可能有五台計算機連接到交換機，而這些計算機都使用私有 IP 地址。當您發出訪問網絡的請求（例如訪問大學的網站）時，路由器會執行網絡地址轉換（ NAT ），該轉換可將您的私有 IP 地址轉換為公共 IP 地址和端口，從而使代表您提出要求。有一個特定範圍的 IP 地址保留為私有（供您和他人使用）供內部使用。 \n', 'tags': '', 'url': 'IPv4 Address Classes.html'}, {'title': 'Assigning an IP Address 分配IP地址', 'text': 'There are four components that make up a properly configured IPv4 network client: IP address, subnet mask, default gateway, and domain name system (DNS) IP address. \n \xa0 \n The first component of a properly configured IPv4 network client is the IP address. This is the logical name assigned to that particular host. In the image below, you can see that the host is assigned 200.200.200.5. No other device on the network can have this exact IP address or conflicts will occur. This IP address is like the device’s first name: no one else in its family (or network in this case) can have this IP address. \n 正確配置 IPv4 網絡客戶端的過程由四個部分組成： IP 地址，子網掩碼，默認網關和域名系統（ DNS ） IP 地址。 \n 正確配置的 IPv4 網絡客戶端的第一部分是 IP 地址。 這是分配給該特定主機的邏輯名稱。 在下圖中，您可以看到為主機分配了 200.200.200.5 。 網絡上的任何其他設備都不能具有此確切的 IP 地址，否則會發生衝突。 該 IP 地址就像設備的名字一樣：其係列（在這種情況下為網絡）中沒有其他人可以使用此 IP 地址。 \n \n Internet protocol (TCP/IP) properties window. Image used under CC-BY license from\xa0 Jason Dion . \n The second component of a properly configured IPv4 network client is the subnet mask. The subnet mask is required to ensure that the host knows what other IP addresses are on its network (which is defined by the subnet mask). In this example, the default class C subnet mask was used, which is 255.255.255.0. This tells the client that its host’s IP address resides on the 200.200.200.0 network, so other IPs in the 200.200.200.x range will be in the same subnet. \n \xa0 \n The third component of a properly configured IPv4 network client is the default gateway. This is the IP address of the device (normally a router) that connects this particular network to another network. For example, if our host wants to talk to someone outside of the 200.200.200.0 network, it would send the message to this default gateway (200.200.200.10 in our example), and this device will forward that request outside of the network. \n \xa0 \n The final component of a properly configured IPv4 network client is the DNS server IP address, or WINS server IP. The DNS server is the domain name system server, and is responsible for converting domain names into IP addresses for the host. For example, if you wanted to go to www.google.com, your host doesn’t know where that is, but the DNS server does know the location. Providing your host with the DNS server address allows it to send the request to the DNS server, which will convert the name into an IP address, and send that address back to the requesting host, which can then go to that IP address with the request. A WINS server is like a DNS server, but is specific to Windows NetBIOS computer names and IP addresses. WINS is usually used inside a Windows network, while DNS is used for clients on the Internet. \n 正確配置的 IPv4 網絡客戶端的第二個組件是子網掩碼。需要子網掩碼以確保主機知道其網絡上還有哪些其他 IP 地址（由子網掩碼定義）。在此示例中，使用了默認的 C 類子網掩碼，即 255.255.255.0 。這告訴客戶端，其主機的 IP 地址位於 200.200.200.0 網絡上，因此 200.200.200.x 範圍內的其他 IP 將位於同一子網中。 \n 正確配置的 IPv4 網絡客戶端的第三個組件是默認網關。這是將該特定網絡連接到另一個網絡的設備（通常是路由器）的 IP 地址。例如，如果我們的主機希望與 200.200.200.0 網絡外部的某人交談，則它將消息發送到該默認網關（在我們的示例中為 200.200.200.10 ），並且該設備將把該請求轉發到網絡外部。 \n 正確配置的 IPv4 網絡客戶端的最後一個組件是 DNS 服務器 IP 地址或 WINS 服務器 IP 。  DNS 服務器是域名系統服務器，並負責將域名轉換為主機的 IP 地址。例如，如果您想訪問 www.google.com ，則您的主機不知道該地址在哪裡，但是 DNS 服務器確實知道該位置。為您的主機提供 DNS 服務器地址可以使其向 DNS 服務器發送請求， DNS 服務器會將名稱轉換為 IP 地址，然後將該地址發送回請求主機，然後主機可以隨請求轉到該 IP 地址。  WINS 服務器類似於 DNS 服務器，但特定於 Windows NetBIOS 計算機名稱和 IP 地址。  WINS 通常在 Windows 網絡內部使用，而 DNS 用於 Internet 上的客戶端。 \n IP addresses are assigned to a client or workstation using either static or dynamic configuration. In static configuration, we find a simple method for assigning an address, but it is more time-consuming. This method requires the technician to input the four required pieces of information that make up an address (IP address, subnet mask, default gateway, and DNS server IP address). This is prone to human errors, since a single, mistyped digit will cause the device to be unable to connect to the network. Also, because each client has to be configured individually and no repeating of IP addresses is allowed, this requires detailed documentation of the used IP addresses and becomes impractical for large networks very quickly. \n Dynamic configuration is much quicker and easier. There are two dynamic configuration methods: DHCP and BOOTP. Dynamic host configuration protocol (DHCP) is simple for large networks and less confusing, because a server handles the assignment of the IP addresses for the client, as well as the subnet mask, default gateway, and DNS server. In practice, the network administrator simply provides the DHCP server with a range of IP addresses to hand out, and the DHCP server does all the work for the network administrator. The DHCP server gives a client an IP address and the associated parameters, as well as a “lease time.” The lease time is the specific amount of time the client is allowed to use that IP address. When the lease is nearing the end of its term, the DHCP server gives the client the option of keeping the lease longer (if it is still using it), or the server can take the lease back to reuse (if it cannot get in touch with the client at the lease renewal). Most large-scale networks and most home networks use DHCP for configuration. \n Bootstrap protocol, more commonly referred to as BOOTP, is an older dynamic addressing protocol and only assigns IP addresses, subnet masks, and default gateways. BOOTP doesn’t support providing DNS server information or WINS server information. BOOTP is considered obsolete now, as it has been replaced by DHCP. DHCP, on the other hand, is based upon the legacy BOOTP protocol but added DNS, WINS and other variables that are related to newer standards like voice-over IP. If your network is dynamically configured, DHCP is most likely in use. \n IP地址使用靜態或動態配置分配給客戶端或工作站。在靜態配置中，我們找到了一種分配地址的簡單方法，但是這比較耗時。此方法要求技術人員輸入組成地址（ IP 地址，子網掩碼，默認網關和 DNS 服務器 IP 地址）的四個必需信息。這很容易發生人為錯誤，因為單個錯誤鍵入的數字將導致設備無法連接到網絡。另外，由於必須分別配置每個客戶端，並且不允許重複 IP 地址，因此這需要使用的 IP 地址的詳細文檔，並且對於大型網絡來說非常不切實際。 \n 動態配置更快，更容易。動態配置方法有兩種： DHCP 和 BOOTP 。動態主機配置協議（ DHCP ）對於大型網絡來說很簡單，並且不易混淆，因為服務器可以處理客戶端 IP 地址的分配以及子網掩碼，默認網關和 DNS 服務器。實際上，網絡管理員只需為 DHCP 服務器提供一系列 IP 地址即可分發，而 DHCP 服務器將為網絡管理員完成所有工作。  DHCP 服務器為客戶端提供 IP 地址和關聯的參數，以及“租用時間”。租用時間是允許客戶端使用該 IP 地址的特定時間。當租約即將到期時， DHCP 服務器會為客戶端提供延長租約（如果仍在使用租約）的選項，或者服務器可以將租約重新使用（如果無法聯繫）與客戶續約）。大多數大型網絡和大多數家庭網絡都使用 DHCP 進行配置。 \n Bootstrap協議（通常稱為 BOOTP ）是一種較舊的動態尋址協議，僅分配 IP 地址，子網掩碼和默認網關。  BOOTP 不支持提供 DNS 服務器信息或 WINS 服務器信息。  BOOTP 現在已被淘汰，因為它已被 DHCP 取代。另一方面， DHCP 基於舊式 BOOTP 協議，但增加了 DNS ， WINS 和其他與諸如語音 IP 之類的新標準相關的變量。如果您的網絡是動態配置的，則最有可能使用 DHCP 。 \n', 'tags': '', 'url': 'Assigning an IP Address 分配IP地址.html'}, {'title': 'IPv6', 'text': 'Internet protocol version 6 was developed to provide more public IP addresses, because the IPv4 public addressing space was running out as a result of the proliferation of network devices in our lives. Now, our cellphones, laptops, tablets, thermostats, refrigerators, TVs, and more are all being connected to the network and they all need IP addresses. Due to the 32-bit addresses used by IPv4, we were limited to 4.2 billion IP addresses, but by increasing the address space to 128-bit addresses in IPv6, the number of IP addresses available has increased to 340 undecillion addresses. This is 5 x 1028 IPv6 addresses for every person on the planet, including children. \n IPv5 was designed, but eventually skipped in implementation, because it was only a 64-bit address and some feared it didn’t provide a large enough pool of available IP addresses. This experimental protocol was abandoned, but many of its concepts were incorporated into the IPv6 protocol, as well as some other protocols. \n Internet協議版本 6 的開發是為了提供更多的公共 IP 地址，因為由於我們生活中網絡設備的激增， IPv4 公共尋址空間已耗盡。 現在，我們的手機，筆記本電腦，平板電腦，恆溫器，冰箱，電視等已全部連接到網絡，並且它們都需要 IP 地址。 由於 IPv4 使用 32 位地址，因此我們只能使用 42 億個 IP 地址，但是通過將地址空間增加到 IPv6 中的 128 位地址，可用的 IP 地址數量已增加到 340 個十億位地址。 這是地球上每個人（包括孩子）的 5 x 1028 IPv6 地址。 \n IPv5是經過設計的，但最終被跳過，因為它只是一個 64 位地址，並且有人擔心它不能提供足夠大的可用 IP 地址池。 該實驗性協議已被放棄，但其許多概念以及其他一些協議已合併到 IPv6 協議中。 \n \n \n \n \n \n Number of Addresses \n \n \n \n \n IPv4 \n \n \n 2 32 \n \n \n 4,294,967,296 \n \n \n \n \n IPv6 \n \n \n 2 128 \n \n \n 340,282,366,920,938,000,000,000,000,000,000,000,000 \n \n \n \n \n \n Benefits of IPv6 IPv6的好處 \n \n IPv6 has many benefits over IPv4, the biggest of which is the number of available IP addresses. In IPv6, there is no broadcast provided, which frees up IP addresses, reduces the amount of traffic sent over the network, and increases bandwidth. Also, IPv6 doesn’t allow packets to be fragmented (broken into pieces) during transmission. This is handled by the protocol by resizing the maximum transmission unit size each time a session is created between two devices. \n A major benefit of IPv6 is that it allows for dual stack implementation, which means that IPv4 and IPv6 can run simultaneously on a device and provide service to the device from either protocol without conflict. IPv6 can also run on top of IPv4 as a tunneled protocol, thereby allowing it to run over older devices, as well. \n Lastly, the packet headers in IPv6 are much simpler than in IPv4. In IPv4, there are 12 fields that must be completely filled out (adding to overhead and complexity), but in IPv6 this was reduced to the bare minimum of five fields. This includes fields such as source and destination address, as well as quality of service priority. \n 與 IPv4 相比， IPv6 有很多好處，其中最大的好處就是可用 IP 地址的數量。在 IPv6 中，沒有提供廣播，這釋放了 IP 地址，減少了通過網絡發送的流量，並增加了帶寬。另外， IPv6 不允許在傳輸過程中將數據包分段（分成碎片）。協議通過每次在兩個設備之間創建會話時調整最大傳輸單元大小來解決此問題。 \n IPv6的主要優點在於它允許雙協議棧實現，這意味著 IPv4 和 IPv6 可以在設備上同時運行，並可以從任一協議向設備提供服務而不會發生衝突。  IPv6 還可以作為隧道協議在 IPv4 之上運行，從而也可以在較舊的設備上運行。 \n 最後， IPv6 中的數據包頭比 IPv4 中的數據包頭簡單得多。在 IPv4 中，必須完全填寫 12 個字段（增加了開銷和復雜性），但是在 IPv6 中，此字段減少到最少五個字段。這包括諸如源地址和目標地址以及服務質量優先級之類的字段。 \n \n IPv6 Address Structure IPv6地址結構 \n While IPv6 has numerous improvements over IPv4, the most notable thing about IPv6 that people see is the format of the address. Instead of the dotted-decimal notation we used in IPv4 with addresses like 192.168.1.1, IPv6 uses eight groupings of four hexadecimal digits in each group. Each group is then broken apart by a colon (:). An example of an IPv6 address is 2002:0000:0000:0000:0000:0000:4815:54ae. \n A hexadecimal digit allows for counting from zero to 15 using the digits 0-9, then the letters A through F. Each hexadecimal digit replaces four binary digits (or four 1s and 0s), allowing us to write an IPv6 address using (at most) 32 hexadecimal digits. \n Luckily, the creators of IPv6 allowed for a shorthand. First, anytime there are leading zeros, they can be dropped. This is equivalent to dropping the leading zeros in the number 0010 to 10. The numbers are equivalent, as long as the zeros are in front of the other digits. The second shorthand technique involves several groupings of four zeros. When multiple groupings of four zeros are present, they can be represented by a double colon (::). Note that you can only use the double colon once per address, because the only way to know how many sets of zeros you’ve replaced with the double colon is to compare the shorthand address with the total number of bits available. \n 儘管 IPv6 相對於 IPv4 進行了許多改進，但是人們看到的關於 IPv6 的最值得注意的事情是地址的格式。  IPv6 不是在 IPv4 中使用像 192.168.1.1 這樣的地址使用的點分十進製表示法，而是在每個組中使用四個十六進制數字組成的八組。然後，每個組用冒號（ :) 分隔。  IPv6 地址的示例是 2002 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 4815 ： 54ae 。 \n 十六進制數字允許使用數字 0-9 從 0 到 15 進行計數，然後使用字母 A 到 F 。每個十六進制數字都替換了四個二進制數字（或四個 1 和 0 ），從而允許我們使用（最多為） 32 個十六進制數字。 \n 幸運的是， IPv6 的創建者允許使用簡寫形式。首先，只要有前導零，就可以將其丟棄。這等效於將數字 0010 中的前導零刪除為 10 。這些數字是等效的，只要零在其他數字的前面即可。第二種速記技術涉及四個零的幾個分組。當存在四個零的多個分組時，可以用雙冒號（： :) 表示。請注意，每個地址只能使用雙冒號一次，因為要知道用雙冒號替換了多少個零集的唯一方法是將速記地址與可用位數進行比較。 \n \n EXAMPLE \n 2002:0000:0000:0000:0000:0000:0000:4815:54ae can be rewritten. One way to rewrite this address is to eliminate the leading zeros. \n 2002： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 4815 ： 54ae 可以重寫。 重寫此地址的一種方法是消除前導零。 \n \n By eliminating the leading zeros, 2002:0000:0000:0000:0000:0000:0000:4815:54ae becomes 2002:0:0:0:0:0:0:4815:54ae. \n Alternatively, this address can be rewritten using a double colon (::) in place of a multiple grouping of four 0s. \n 通過消除前導零， 2002 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 4815 ： 54ae 變為 2002 ： 0 ： 0 ： 0 ： 0 ： 0 ： 0 ： 0 ： 4815 ： 54ae 。 \n 或者，可以使用雙冒號（： :) 代替四個 0 的多個分組來重寫此地址。 \n \n By replacing multiple groupings of four 0s with a double colon, 2002:0000:0000:0000:0000:0000:0000:4815:54ae becomes 2002::4815:54ae. \n 通過用雙冒號替換四個 0 的多個分組， 2002 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 0000 ： 4815 ： 54ae 變為 2002 :: 4815 ： 54ae 。 \n \n EXAMPLE \n 2009:0123:4040:0000:0000:0000:000A:100B can be written by both eliminating leading zeros and using double colons. \n 可以通過消除前導零和使用雙冒號來編寫 2009 ： 0123 ： 4040 ： 0000 ： 0000 ： 0000 ： 000A ： 100B 。 \n \n 2009:0123:4040:0000:0000:0000:000A:100B becomes 2009:123:4040::A:100B. \n As you can see, the IPv6 addresses are more complex than their IPv4 counterparts, but over time, you will get used to seeing how they are written, and what the different notation indicates. \n 2009： 0123 ： 4040 ： 0000 ： 0000 ： 0000 ： 000A ： 100B 變為 2009 ： 123 ： 4040 :: A ： 100B \n 如您所見， IPv6 地址比其對應的 IPv4 地址要復雜得多，但是隨著時間的流逝，您將習慣於看到它們的寫法以及不同符號的含義。 \n IPv6 Data Flows IPv6資料流向圖 \n Data flows in IPv6 are similar to those in IPv4. In fact, unicast and multicast work identical to their IPv4 counterparts. But, because there is no broadcast in IPv6, it has been replaced with “anycast.” Anycast allows data to travel from a single source device to the nearest of multiple, but specific, devices on a network. Anycasting is designed to let one host initiate the efficient updating of router tables for a group of hosts. IPv6 can determine which gateway host is closest and sends the packets to that host as though it were a unicast communication. In turn, that host can anycast to another host in the group until all routing tables are updated. \n IPv6中的數據流類似於 IPv4 中的數據流。 實際上，單播和多播的工作方式與 IPv4 相同。 但是，由於 IPv6 中沒有廣播，因此已將其替換為“任何廣播”。  Anycast 允許數據從單個源設備傳輸到網絡上多個（但特定的）設備中最接近的一個。 任意廣播旨在讓一個主機為一組主機啟動路由器表的有效更新。  IPv6 可以確定哪個網關主機最接近，並將數據包發送到該主機，就好像它是單播通信一樣。 相應地，該主機可以向組中的另一台主機任意廣播，直到更新所有路由表為止。 \n', 'tags': '', 'url': 'IPv6.html'}, {'title': 'Classful Vs\xa0 Classless Addressing\xa0 Subnet and CIDR', 'text': '相對於 無類尋址：子網和 CIDR \n \n The IP address always determines the class of a network and never the subnet. When the IP addresses match, the network is said to be using a “classful” scheme. However, this allows for many wasted IP addresses when a company needs more publicly routable IP addresses than the address class they are using offers. Classless inter-domain routing (CIDR) was developed in order to make the IP addressing scheme more efficient and to delay the depletion of IPv4 addresses. Essentially, some of the network bits in the default subnet mask are borrowed and used for the host portion of the network. For example, if a business needs 300 public IP addresses, then class C addresses would be too small because of the 254 device limitation, and class B would be excessively large. With CIDR, a business could be assigned an IP address range with a subnet of 255.255.254.0/23. In CIDR notation, “/23” indicates that the first 23 bits of the address are the network part of the address, which leaves the last nine bits for host addresses, rather than the eight bits that would be available in classful addressing. That means there will now be 510 IP numbers available rather than 254. \n IP地址始終確定網絡的類別，而不是子網。如果 IP 地址匹配，則稱網絡正在使用“分類”方案。但是，當公司需要比他們使用的地址類更多的可公共路由的 IP 地址時，這會浪費許多 IP 地址。開發無類域間路由（ CIDR ）的目的是使 IP 尋址方案更高效並延遲 IPv4 地址的耗盡。本質上，默認子網掩碼中的某些網絡位被借用並用於網絡的主機部分。例如，如果一家企業需要 300 個公共 IP 地址，則由於 254 個設備限制， C 類地址將太小，而 B 類將太大。使用 CIDR ，可以為企業分配 IP 地址範圍，其子網為 255.255.254.0/23 。在 CIDR 表示法中，“  / 23 ”表示地址的前 23 位是地址的網絡部分，剩下的最後 9 位用於主機地址，而不是分類尋址中可用的 8 位。這意味著現在將有 510 個 IP 號碼，而不是 254 個。 \n \n Private Vs. Public IP Addresses 私人 vs.  公用 IP 地址 \n IPv4 depletion affects public addresses that are routable on the Internet by such devices as routers and servers, as well as the device used to connect your home to the Internet. Whether it is a cable modem, DSL, or FIOS, that device has a public IP address that communicates with your Internet service provider (ISP). This is an example of a WAN. The LAN (local area network) is wholly comprised of private IP addresses. \n IPv4耗盡會影響路由器和服務器等設備以及用於將您的房屋連接到 Internet 的設備在 Internet 上可路由的公共地址。 無論是電纜調製解調器， DSL 還是 FIOS ，該設備都具有與 Internet 服務提供商（ ISP ）通信的公共 IP 地址。 這是 WAN 的示例。  LAN （局域網）完全由專用 IP 地址組成。 \n \n \n \n \n RFC1918 name \n \n \n IP address range \n \n \n Number of addresses \n \n \n Largest CIDR block (subnet mask) \n \n \n Host ID size \n \n \n Mask bits \n \n \n Classful description \n \n \n \n \n \n \n 24-bit block \n \n \n 10.0.0.0 - 10.255.255.255 \n \n \n 16,777,216 \n \n \n 10.0.0.0/8 (255.0.0.0) \n \n \n 24 bits \n \n \n 8 bits \n \n \n single class A network \n \n \n \n \n 20-bit block \n \n \n 172.16.0.0 - 172.31.255.255 \n \n \n 1,048,576 \n \n \n 172.16.0.0/12 (255.240.0.0) \n \n \n 20 bits \n \n \n 12 bits \n \n \n 16 contiguous class B networks \n \n \n \n \n 16-bit block \n \n \n 192.168.0.0 - 192.168.255.255 \n \n \n 65,536 \n \n \n 192.168.0.0/16 (255.255.0.0) \n \n \n 16 bits \n \n \n 16 bits \n \n \n 256 contiguous class C networks \n \n \n \n \n Table used under CC-BY license from\xa0 Wikipedia . \n In order for a LAN node to access the Internet, IPv4 uses network address translation (NAT), which is a technique where the gateway/router would replace the outgoing private IPv4 address with the publically routable address assigned by the ISP. \n 為了使 LAN 節點能夠訪問 Internet ， IPv4 使用網絡地址轉換（ NAT ），該技術是網關 / 路由器將出站專用 IPv4 地址替換為 ISP 分配的可公開路由的地址。 \n \xa0 \n Static Vs. Dynamic IP Addressing 靜態與 動態 IP 尋址 \n Historically, the client (a workstation or a printer) would be assigned a static IP address manually using the operating system IPv4 configuration. Remember, you must have unique IP addresses in any network. Imagine how difficult it was in a large corporation to track all the different nodes and IP addresses. Dynamic host configuration protocol (DHCP) solves this problem by having one device (a server or a router) automatically assign an IP address. In the current network structure, you would still assign static IP addresses to devices that must have guaranteed connectivity: servers, routers, managed switches, etc. However, DHCP can provide many benefits in networking maintenance with the abundant wireless devices such as cell phones, tablets, and laptops coming in and out of a network daily. Companies have developed policies for employees to bring their own devices to work, thus accessing the corporate network. DHCP will give the client setup parameters (gateway, domain, and name servers), keeping a specific pool of IP addresses, and offering timed leases for a device’s IP assignment. \n 從歷史上看，將使用操作系統 IPv4 配置為客戶端（工作站或打印機）手動分配靜態 IP 地址。請記住，任何網絡中都必須具有唯一的 IP 地址。想像一下，在大型公司中跟踪所有不同的節點和 IP 地址有多麼困難。動態主機配置協議（ DHCP ）通過讓一台設備（服務器或路由器）自動分配 IP 地址來解決此問題。在當前的網絡結構中，您仍將靜態 IP 地址分配給必須保證連接性的設備：服務器，路由器，受管理的交換機等。但是， DHCP 可以通過大量的無線設備（例如手機，平板電腦和筆記本電腦每天進出網絡。公司已製定政策，要求員工使用自己的設備來工作，從而訪問公司網絡。  DHCP 將提供客戶端設置參數（網關，域和名稱服務器），保留特定的 IP 地址池，並為設備的 IP 分配提供定時租用。 \n \xa0 \n APIPA Link-Local APIPA 本地鏈接 \n Link-local addresses are special addresses assigned by the operating system when either there is no statically assigned IP address, or the DHCP does not assign one to the network interface. Link-local addresses are not routable and only function in a LAN segment. In IPv4, the address range is 169.254.0.0/16 and the form is 169.254.x.x. In IPv6, the form is FE80::/64. In a Microsoft OS, the link-local address is referred to as automatic private IP addressing (APIPA). \n If you are troubleshooting an NIC (network interface card) that is supposed to be connected and you see a link-local address, this indicates that there is something wrong with the configuration because the OS assigned the address. \n 當沒有靜態分配的 IP 地址，或者 DHCP 沒有為網絡接口分配一個 IP 地址時，本地鏈接地址是操作系統分配的特殊地址。 本地鏈接地址不可路由，只能在 LAN 網段中使用。 在 IPv4 中，地址範圍為 169.254.0.0/16 ，格式為 169.254.x.x 。 在 IPv6 中，格式為 FE80 :: / 64 。 在 Microsoft 操作系統中，本地鏈接地址稱為自動專用 IP 尋址（ APIPA ）。 \n 如果要對應該連接的 NIC （網絡接口卡）進行故障排除，並且看到鏈接本地地址，則表明配置有問題，因為操作系統分配了該地址。 \n \n Client-side DHCP 客戶端 DHCP \n DHCP works by having an authoritative device, either a server or a router, offering to assign the IP address. In order for this to work, the client must be configured to look for the DHCP authority, and confirm that it will accept the IP assignment. These settings are located in “network connections” through either the network and sharing center or directly through the control panel. The configuration settings are located in the properties of the connection under either IPv4 or IPv6. \n DHCP通過擁有授權設備（服務器或路由器）來分配 IP 地址而起作用。 為了使它起作用，必須將客戶端配置為尋找 DHCP 授權，並確認它將接受 IP 分配。 這些設置通過網絡和共享中心位於“網絡連接”中，也可以直接通過控制面板位於“網絡連接”中。 配置設置位於 IPv4 或 IPv6 下的連接屬性中。 \n \xa0 \n Client-side DNS settings 客戶端 DNS 設置 \n The domain name system (DNS) is a part of the Internet protocol that translates IP addresses to name addresses. There is a setting located in the network properties section of the IPv4 or IPv6 property window that allows for the manual setting of the the domain name system (DNS) server address. The local DNS cache will keep a local record of IP address to name conversion for both LAN devices and Internet addresses. Alternate DNS server addresses can be added to the client to assist in name resolution, thus improving data flow. \n 域名系統（ DNS ）是 Internet 協議的一部分，該協議將 IP 地址轉換為名稱地址。  IPv4 或 IPv6 屬性窗口的網絡屬性部分中有一個設置，允許手動設置域名系統（ DNS ）服務器地址。 本地 DNS 緩存將保留 IP 地址到 LAN 設備和 Internet 地址的名稱轉換的本地記錄。 可以將備用 DNS 服務器地址添加到客戶端以幫助名稱解析，從而改善數據流。 \n \n Gateway 閘道器 \n The gateway is the device that connects different networks types together. In most SOHO (small office, home office) environments today, this is the router that connects the LAN to the ISP modem through the WAN port (cable, DSL, or FIOS), which provides Internet access. In a larger corporate environment, it is the last router in the LAN that connects to a WAN link, and then passes the IP packets to their destination. The difference is that in a larger corporate environment, there can be multiple LAN segments and routers between the client workstation and the gateway. \n 網關是將不同網絡類型連接在一起的設備。 在當今的大多數 SOHO （小型辦公室，家庭辦公室）環境中，這是通過 WAN 端口（電纜， DSL 或 FIOS ）將 LAN 連接到 ISP 調製解調器的路由器，可以提供 Internet 訪問。 在較大的公司環境中，它是 LAN 中的最後一個路由器，該路由器連接到 WAN 鏈接，然後將 IP 數據包傳遞到其目的地。 區別在於，在較大的公司環境中，客戶端工作站和網關之間可以有多個 LAN 網段和路由器。 \n \n', 'tags': '', 'url': 'Classful Vs\xa0 Classless Addressing\xa0 Subnet and CIDR.html'}, {'title': 'Windows Networking Windows網絡', 'text': 'Windows networking is nearly identical in all aspects from Vista through to Windows 10. To access the network settings, go to either the control panel, then “network and Internet,” then “network and sharing center,” or right-click the “open network and sharing center” icon in the system tray (next to the clock). \n 從 Vista 到 Windows 10 ， Windows 聯網在各個方面都幾乎相同。要訪問網絡設置，請轉到控制面板，然後依次單擊“網絡和 Internet ”，“網絡和共享中心”，或右鍵單擊“打開”。 網絡和共享中心”圖標（位於時鐘旁邊）。 \n \n Accessing the network and sharing center from the system tray. Image used under CC-BY license from Russell Burchill. \n Select (1) Ethernet, then (2) properties, then (3) TCP/IPv4. \n 選擇（ 1 ）以太網，然後選擇（ 2 ）屬性，然後選擇（ 3 ） TCP / IPv4 。 \n \n The Ethernet properties window of a particular network. Image used under CC-BY license from Russell Burchill. \n Remember, a technician will ensure settings fit the current network. Most networks are set up with DHCP, which will provide the workstation with an IP address, gateway, and DNS server address. \n Double-click the IPv4 properties dialogue box and set both radio buttons to “obtain (an IP address/DNS server address) automatically.” The window on the right in the image below allows for the APIPA address to be automatically assigned or for the user to configure a static IPv4 address. \n 請記住，技術人員將確保設置適合當前網絡。 大多數網絡都設置有 DHCP ，它將為工作站提供 IP 地址，網關和 DNS 服務器地址。 \n 雙擊“  IPv4 屬性”對話框，並將兩個單選按鈕設置為“自動獲取（ IP 地址 / DNS 服務器地址）”。 下圖右側的窗口允許自動分配 APIPA 地址或允許用戶配置靜態 IPv4 地址。 \n \n TCP/IPv4 properties windows. Image used under CC-BY license from Russell Burchill. \n', 'tags': '', 'url': 'Windows Networking Windows網絡.html'}, {'title': 'U14', 'text': '', 'tags': '', 'url': 'U14.html'}, {'title': 'Overview 概述', 'text': 'In this lesson, we will discuss transmission control protocol (TCP) and user datagram protocol (UDP), as well as their associated ports and protocols. We will specifically address the various email ports and protocols in use today, as well as discussing secure sockets layer/transport layer security (SSL/TLS) in the context of web security. Then, we will discuss file transfer protocol (FTP) and hypertext transfer protocol (HTTP) and their use on the Internet today, as well as some older technologies such as Telnet and its more secure alternative, secure shell (SSH). \n 在本課程中，我們將討論傳輸控制協議（TCP）和用戶數據報協議（UDP）以及它們相關的端口和協議。 我們將專門解決當今使用的各種電子郵件端口和協議，並在Web安全的背景下討論安全套接字層/傳輸層安全（SSL / TLS）。 然後，我們將討論文件傳輸協議（FTP）和超文本傳輸協議（HTTP）及其在當今Internet上的使用，以及一些較老的技術，例如Telnet及其更安全的替代方法，安全外殼（SSH）。 \n', 'tags': '', 'url': 'Overview 概述.html'}, {'title': 'TCP and UDP', 'text': 'TCP is a connection-oriented protocol that ensures the reliable transport of data segments from one device to another. During transmission, if a segment is dropped, it will be detected and resent or retransmitted by the originator device. Each communication is acknowledged upon receipt, providing a secure model to ensure successful communications. This type of transmission is great for all network data types, especially those that need delivery to be assured. \n When a TCP communication is initiated, the originator and receiver perform a “three-way handshake” before starting the data transmission. In the first step, the originator sends a packet with a synchronization (SYN) flag set. Next, the receiver acknowledges receipt of this SYN flagged packet by sending back a synchronization-acknowledged (SYN-ACK) flagged packet. Finally, the originator sends an acknowledgement of the synchronization-acknowledged flagged packet, and then data transmission occurs. \n TCP是一種面向連接的協議，可確保將數據段從一台設備可靠地傳輸到另一台設備。在傳輸過程中，如果某個段丟失，則發起方設備將檢測到該段並將其重新發送或重新發送。每次通信在收到後都會得到確認，從而提供一個安全的模型來確保成功進行通信。這種傳輸方式適用於所有網絡數據類型，尤其是那些需要確保傳輸的網絡數據類型。 \n 啟動TCP通信時，發起方和接收方在開始數據傳輸之前執行“三向握手”。 第一步，發起方發送一個設置了同步（SYN）標誌的數據包。 接下來，接收器通過發回同步確認（SYN-ACK）標記的數據包來確認此SYN標記的數據包的接收。 最後，始發者發送對已同步確認的標記數據包的確認，然後發生數據傳輸。 \n EXAMPLE \n Think of this like two students who want to discuss an important project that is upcoming. The first student, Bob, says to Jane, “Jane, I want to talk to you.” Next, Jane says, “Bob, I acknowledge that you want to talk to me and I am ready to listen.” Finally, Bob tells her, “Jane, I understand you are ready to listen. Let’s talk.” At this point, the two students can talk, knowing they are both ready to listen to each other. \n 就像兩個想討論即將開展的重要項目的學生一樣。 第一位學生鮑勃對簡說：“簡，我想和你說話。” \xa0 接下來，簡說：“鮑勃，我承認你想和我說話，我已經準備好傾聽。” \xa0 最後，鮑勃告訴她：“簡，我知道你已經準備好聽了。 讓我們談談。” \xa0 此時，兩個學生可以交談，知道他們倆都準備好了互相傾聽。 \n \n Diagram of TCP three-way handshake. Image used under CC-BY license from\xa0 National STEM Consortium . \n UDP, or user datagram protocol, was developed as a connectionless protocol in order to increase the speed of the network over TCP transmissions. Because of the three-way handshake in TCP, as well as all the delivery assurance and quality control, TCP has a good amount of network overhead that slows down its communications. Network engineers realized that sometimes you don’t need delivery assurance or quality control. So UDP was established. \n UDP is considered unreliable, because if a segment is dropped during transmission, the sending device doesn’t know and doesn’t care. There is no retransmission. Once data is sent, it is gone. This is good, though, for audio and video streaming. In these applications, the data transferred is enormously large, and if a single segment is dropped it doesn’t affect the overall quality of the audio or video sent. \n UDP（或用戶數據報協議）被開發為無連接協議，目的是通過TCP傳輸提高網絡速度。由於TCP中的三向握手以及所有的傳送保證和質量控制，TCP具有大量的網絡開銷，從而降低了其通信速度。網絡工程師意識到有時您不需要交付保證或質量控制。這樣就建立了UDP。 \n UDP被認為是不可靠的，因為如果在傳輸過程中丟棄了一個網段，則發送設備將不知道也不在乎。 沒有重傳。 數據一旦發送，就消失了。 但是，這對於音頻和視頻流來說是很好的。 在這些應用程序中，傳輸的數據非常大，如果丟棄單個段，則不會影響所發送的音頻或視頻的整體質量。 \n EXAMPLE \n I like to think of UDP as my college calculus teacher. He started at one side of the board at 8 a.m., and by 9 a.m. he was done at the other side of the board. He never asked if the students understood what he said or wrote, he just kept transmitting. This is a great example of UDP. \n 我喜歡將UDP視為我的大學微積分老師。 他在上午8點從董事會的一側開始，到上午9點，他在董事會的另一側完成了工作。 他從不問學生是否理解他所說或寫的內容，他只是不斷地傳播。 這是UDP的一個很好的例子。 \n \n Diagram of UDP transmission. Image used under CC-BY license from\xa0 National STEM Consortium . \n TCP Vs. UDP\xa0\xa0 TCPVs。UDP協議 \n TCP and UDP have many differences. TCP is reliable, but UDP is unreliable. TCP focuses on connection-oriented communications using the three-way handshake, while UDP is connectionless. TCP uses windowing, discussed in more detail later, to control the amount of data sent at a given time based on changing network speeds, but UDP simply transmits everything once with no windowing. TCP also supports segment sequencing; UDP just hopes it gets to the destination in the right order. Finally, TCP waits for acknowledgements, but UDP just hopes it got there. To simplify it, TCP is an assured and reliable communication method, UDP is just a best-effort model. \n TCP和UDP有很多區別。 TCP是可靠的，但UDP是不可靠的。 TCP專注於使用三向握手的面向連接的通信，而UDP是無連接的。 TCP使用開窗（稍後將更詳細地討論）來基於不斷變化的網絡速度來控制在給定時間發送的數據量，但是UDP僅傳輸所有信息一次而沒有開窗。 TCP還支持段排序； UDP只是希望它以正確的順序到達目的地。 最後，TCP等待確認，但是UDP只是希望它到達目的地。 為簡化起見，TCP是一種有保證且可靠的通信方法，UDP只是一種盡力而為的模型。 \n \n \n', 'tags': '', 'url': 'TCP and UDP.html'}, {'title': 'TCP IP Stack', 'text': 'Each client and server has an IP address. Clients and servers are identified on the network by their IP addresses. In addition to an IP address, each machine has numerous “ports” that we can utilize. A port is an endpoint to a logical connection. A client program specifies a particular server program on a computer in a network by identifying a port. Ports allow a single client to communicate simultaneously with multiple other devices, separating each session by using a designated port number. \n 每個客戶端和服務器都有一個IP地址。 客戶端和服務器通過其IP地址在網絡上進行標識。 除了IP地址外，每台機器都有許多我們可以利用的“端口”。 端口是邏輯連接的端點。 客戶端程序通過識別端口來指定網絡中計算機上的特定服務器程序。 端口允許單個客戶端與多個其他設備同時通信，並使用指定的端口號分隔每個會話。 \n \n EXAMPLE \n The best way to envision this is to think of an apartment building. Your building’s address may be 123 Main Street; this would be equivalent to your IP address. But how does the mailman know which door to use when delivering your package, since multiple families live at 123 Main Street? The mailman uses your apartment number, which defines which door in the building he would knock on to deliver your package. These apartment doors would be called ports in a computer, and the computer knows which programs and sessions requested information over the network by tracking the port numbers that make the requests. \n 設想此問題的最佳方法是考慮一棟公寓樓。 您建築物的地址可能是123 Main Street； 這相當於您的IP地址。 但是由於多個家庭居住在Main Street 123號，郵遞員如何知道在運送包裹時要使用哪扇門？ 郵遞員使用您的公寓號碼，該號碼定義了他敲樓時要送出包裹的門。 這些公寓門在計算機中稱為端口，計算機通過跟踪發出請求的端口號來知道哪些程序和會話在網絡上請求了信息。 \n \n EXAMPLE \n Similar to an apartment building, on the network, let’s assume the client has an IP address of 10.1.1.1, which we call the source IP. The computer’s web browser chose a port number of 1248 from which to initiate the communication and a destination of 172.16.1.2 (which would be a web server for some company) and a destination port of 80 (which is the common port number for all web page traffic). The server then replies from its IP address (172.16.1.2) and port 80 to the client who made the request at their IP address of 10.1.1.1 and port 1248. As they continue the conversation, they will continue to use these IP addresses and ports, and at the same time the web server can maintain other communications with other customers, just like the client can surf to other websites in other tabs in their browser simultaneously without mixing the data, since they are separated by the port numbers. The diagram below illustrates this communication. \n 與網絡上的公寓樓類似，我們假設客戶端的IP地址為10.1.1.1，我們將其稱為源IP。 計算機的Web瀏覽器選擇了用於發起通信的端口號1248，以及目的地172.16.1.2（對於某些公司而言將是Web服務器）和目的端口80（這是所有Web站點的通用端口號）。頁面訪問量）。 然後，服務器從其IP地址（172.16.1.2）和端口80答复給以其IP地址10.1.1.1和端口1248發出請求的客戶端。隨著他們繼續進行對話，他們將繼續使用這些IP地址和端口，同時Web服務器可以維持與其他客戶的其他通信，就像該客戶可以同時瀏覽其瀏覽器其他標籤中的其他網站一樣，而無需混合數據， 因為它們由端口號分隔。 下圖說明了這種通信。 \n \n Port numbers are considered either well-known or ephemeral. Well-known port numbers are between 1 and 1023, like the web browsing port number of 80 in our last example. Port 80 is reserved as a well-known port for all hypertext transfer protocol (HTTP) traffic. Ephemeral port numbers are considered “high-numbered” ports and start at 1024 and go up to 65,535. These are usually the ports used by the client making the request, as we saw in our web browsing example, above, when the client chose port 1248 as its requesting port. \n 端口號被認為是眾所周知的或短暫的。 眾所周知的端口號在1到1023之間，例如我們上一個示例中的Web瀏覽端口號80。 端口80保留為所有超文本傳輸協議（HTTP）通信的眾所周知的端口。 臨時端口號被認為是“高編號”端口，起始於1024，最高可達65,535。 這些通常是客戶端發出請求的端口，正如我們在上面的Web瀏覽示例中所見，當客戶端選擇端口1248作為其請求端口時。 \n \n Port numbers and IP addresses. Image used under CC-BY license from\xa0 National STEM Consortium . \n \n', 'tags': '', 'url': 'TCP IP Stack.html'}, {'title': 'Networking Transfer Protocols\xa0網絡傳輸協議', 'text': "TCP/IP contains a suite of many different transfer protocols for routing information across networks. Each protocol uses a different well-known port to keep its traffic separate from the others. Web browsing occurs using either hypertext transfer protocol (HTTP) or hypertext transfer protocol secure (HTTPS). When it uses HTTP, it uses port 80. If, however, the client requests that the site be sent securely using encryption, then it uses the HTTPS protocol and port 443. When being sent securely, the client and server use either secure sockets layer (SSL) or transport layer security (TLS). These additional layers are put on top of the existing HTTP standard to encrypt the data connection between the client and the server. \n In addition to browsing the web, there are many other things that can be done on the network and each uses its own dedicated port number to keep the traffic separate. File transfer protocol (FTP) uses port 21. FTP is a standard network protocol used to transfer computer files from one host to another host over a TCP-based network, such as the Internet. FTP is built on a client-server architecture and uses separate control and data connections between the client and the server. \n Telnet is a text-based remote access program for computers that communicates over port 23. Telnet is a user command and an underlying TCP/IP protocol for accessing computers remotely. Through telnet, an administrator or another user can access someone else's computer remotely. Unfortunately, telnet is an unsecured protocol where all the information between the client and server is communicated in clear text, so anyone who can capture this data can read it easily. For this reason, secure shell (SSH), which uses port 22, was introduced to replace telnet. SSH is a cryptographic (encrypted) network protocol for initiating text-based shell sessions on remote machines, similar to telnet but with the added strength of encryption. \n The domain name system (DNS) is a hierarchical distributed naming system for computers, services, or any resource connected to the Internet or to a private network. It allows for the translation of IP addresses to domain names, and from domain names to IP addresses. Remote desktop protocol (RDP) is a proprietary protocol developed by Microsoft, which provides users with a graphical interface to connect to other computers over a network connection using port 3389. The user employs RDP client software for this purpose, while the other computer must run RDP server software. RDP is a huge step up over telnet and SSH, because you receive a graphical environment to control the other user’s machine, just as if you were sitting in front of their Windows desktop. \n Simple network management protocol (SNMP) is a popular protocol for network management. It is used for collecting information from and configuring network devices, such as servers, printers, hubs, switches, and routers, on an Internet protocol (IP) network. SNMP traffic is sent over port 161. \n Server message block (SMB) is a network protocol used for providing shared access to files, printers, and serial ports and miscellaneous communications between nodes on a network using port 139. \n The lightweight directory access protocol (LDAP) is a directory service protocol that runs over port 389. LDAP provides a mechanism used to connect to, search, and modify Internet directories. The LDAP directory service is based on a client-server model. \n TCP / IP包含一組用於在網絡之間路由信息的許多不同的傳輸協議。每種協議都使用不同的知名端口，以使其流量彼此獨立。使用超文本傳輸協議（HTTP）或安全超文本傳輸協議（HTTPS）進行Web瀏覽。當使用HTTP時，它將使用端口80。但是，如果客戶端請求使用加密安全地發送站點，則它將使用HTTPS協議和端口443。在安全發送時，客戶端和服務器將使用安全套接字層（SSL）或傳輸層安全性（TLS）。這些額外的層放在現有HTTP標準之上，以加密客戶端和服務器之間的數據連接。 \n 除了瀏覽網絡之外，網絡上還有許多其他事情可以做，每件事都使用自己的專用端口號來保持流量分開。 文件傳輸協議（FTP）使用端口21。FTP是一種標準網絡協議，用於通過基於TCP的網絡（例如Internet）將計算機文件從一台主機傳輸到另一台主機。 FTP建立在客戶端-服務器體系結構上，並在客戶端和服務器之間使用單獨的控制和數據連接。 \n Telnet是用於通過端口23進行通信的計算機的基於文本的遠程訪問程序。Telnet是用戶命令和用於遠程訪問計算機的基礎TCP / IP協議。 通過telnet，管理員或其他用戶可以遠程訪問其他人的計算機。 不幸的是，telnet是一種不安全的協議，其中客戶端與服務器之間的所有信息均以明文形式進行通信，因此任何可以捕獲此數據的人都可以輕鬆地讀取它。 因此，引入了使用端口22的安全外殼（SSH）來代替telnet。 SSH是一種加密（加密）網絡協議，用於在遠程計算機上啟動基於文本的Shell會話，類似於telnet，但具有增強的加密強度。 \n 域名系統（DNS）是用於計算機，服務或連接到Internet或專用網絡的任何資源的分層分佈式命名系統。 它允許將IP地址轉換為域名，也可以將域名轉換為IP地址。 遠程桌面協議（RDP）是Microsoft開發的專有協議，它為用戶提供圖形界面以使用端口3389通過網絡連接連接到其他計算機。用戶為此目的使用RDP客戶端軟件，而另一台計算機必須運行RDP服務器軟件。 RDP與telnet和SSH相比是一個巨大的進步，因為您將獲得一個圖形環境來控制其他用戶的計算機，就像您坐在他們的Windows桌面前一樣。 \n 簡單網絡管理協議（SNMP）是一種流行的網絡管理協議。 它用於從Internet協議（IP）網絡上的服務器，打印機，集線器，交換機和路由器等網絡設備收集信息並對其進行配置。 SNMP通信通過端口161發送。 \n 服務器消息塊（SMB）是一種網絡協議，用於提供對文件，打印機和串行端口的共享訪問以及使用端口139的網絡上節點之間的其他通信。 \n 輕型目錄訪問協議（LDAP）是運行在端口389上的目錄服務協議。LDAP提供了一種用於連接，搜索和修改Internet目錄的機制。 LDAP目錄服務基於客戶端-服務器模型。 \n \n Email\xa0 電子郵件 \n Email has evolved a lot over the years, but still operates on three main protocols. Simple mail transfer protocol (SMTP) is an Internet standard for sending email and most outbound email is sent using SMTP. SMTP uses port 25 to send email from network devices. \n POP3 is the most common account type for personal email, but messages are typically deleted from the server when you check your email. \n Internet message access protocol (IMAP) servers let you work with email messages without downloading them to your computer first. This allows for email to be synchronized (synced) across multiple devices, including your desktop, laptop, tablet, and smartphone. IMAP uses port 143 to receive and synchronize your email. The real benefit of using IMAP, especially in today’s multiple device access world, is that it can change the read and delete state of messages across the multiple devices. For example, if I read a message on my phone, when I log into my desktop, the message will also show as having been read already. \n 多年來，電子郵件已經有了很大的發展，但仍在三種主要協議上運行。簡單郵件傳輸協議（SMTP）是用於發送電子郵件的Internet標準，大多數出站電子郵件都是使用SMTP發送的。SMTP使用端口25從網絡設備發送電子郵件。 \n POP3是最常見的個人電子郵件帳戶類型，但是當您檢查電子郵件時，通常會將郵件從服務器中刪除。 \n Internet郵件訪問協議（IMAP）服務器使您可以處理電子郵件，而無需先將其下載到計算機上。 這允許跨多個設備（包括台式機，筆記本電腦，平板電腦和智能手機）同步（同步）電子郵件。 IMAP使用端口143接收和同步您的電子郵件。 使用IMAP的真正好處（尤其是在當今的多設備訪問世界中）是，它可以更改跨多個設備的消息的讀取和刪除狀態。 例如，如果我在手機上閱讀了一條消息，則當我登錄到桌面時，該消息也將顯示為已被閱讀。 \n", 'tags': '', 'url': 'Networking Transfer Protocols\xa0網絡傳輸協議.html'}, {'title': 'FTP', 'text': 'In the OSI (Open Systems Interconnection) model, the application layer uses protocols such as trivial file transfer protocol (TFTP), file transfer protocol (FTP), and file transfer protocol secure (FTPS using TLS/SSL) to allow users to migrate data in a client-server model. FTP concerns itself with data only and as such eliminates the overhead of extraneous information such as what HTTP allows in addition to the actual data (advertisements, banners, images, etc.). This alleviates processing and bandwidth overhead and allows the client to simply retrieve the data from the server. \n FTP services can be accessed using client software such as ftp.exe (provided in all Microsoft operating systems), third-party software such as Filezilla or WinSCP, and any modern/current browser. Most light-duty users outside a corporate environment will not use a client FTP (or its secure version) because web browsers can negotiate FTP as well as HTTP. Public FTP servers allow for an anonymous user name so the client can reach file directories specifically designed for public access. \n These network communications are passed through the presentation layer to the session layer, where sockets and sessions are created using logical port numbers as defined by TCP or UDP. TCP is stateful, connection-oriented and reliable. UDP is stateless, connectionless, and less reliable. The combination of source and destination address coupled with the logical port number creates a network socket, which establishes the session for process-to-process communication. \xa0 The material in this section is used under CC-BY license from \xa0 https://en.wikipedia.org/wiki/Transport_layer . \n 在OSI（開放系統互連）模型中，應用程序層使用諸如簡單文件傳輸協議（TFTP），文件傳輸協議（FTP）和安全文件傳輸協議（使用TLS / SSL的FTPS）之類的協議來允許用戶遷移數據在客戶端-服務器模型中。FTP僅關注數據本身，因此消除了額外信息的開銷，例如除了實際數據（廣告，橫幅，圖像等）之外，HTTP允許的信息。這減輕了處理和帶寬開銷，並使客戶端可以簡單地從服務器檢索數據。 \n 可以使用諸如ftp.exe（在所有Microsoft操作系統中提供）之類的客戶端軟件，諸如Filezilla或WinSCP之類的第三方軟件以及任何現代/最新的瀏覽器來訪問FTP服務。 公司環境之外的大多數輕型用戶將不會使用客戶端FTP（或其安全版本），因為Web瀏覽器可以協商FTP以及HTTP。 公用FTP服務器允許使用匿名用戶名，以便客戶端可以訪問專門為公用訪問而設計的文件目錄。 \n 這些網絡通信通過表示層傳遞到會話層，在會話層中，使用由TCP或UDP定義的邏輯端口號創建套接字和會話。 TCP是有狀態的，面向連接的且可靠的。 UDP是無狀態，無連接且可靠性較低。 源地址和目標地址以及邏輯端口號的組合創建了一個網絡套接字，該網絡套接字建立了進程間通信的會話。 \xa0 本節中的材料根據 https://en.wikipedia.org/wiki/Transport_layer的 CC-BY許可使用 。 \n \n Active vs. Passive\xa0 主動與被動 \n Active FTP is a point-to-point connection that the client initiates and connects to the FTP server port 21 for commands and port 20 for data. That means that the server will actively initiate the connections back to the client’s listening port and will require the client to allow these connections, which the firewall blocks by default. Passive FTP allows the client to initiate the data connection on port 21, and then the FTP server moves the command and data connections to random ports on the server (with numbers higher than 1023). By initiating the connection from the client side, the burden of allowing a pass-through on the firewall resides with the FTP server administrator, who is better equipped to set a range of ports allowing connectivity. \n For more information on active vs. passive FTP, visit this \xa0 website . \n 主動FTP是點對點連接，客戶端啟動該點並連接到FTP服務器端口21（用於命令）和端口20（用於數據）。這意味著服務器將主動啟動回到客戶端偵聽端口的連接，並要求客戶端允許這些連接，防火牆默認情況下會阻止這些連接。被動FTP允許客戶端在端口21上啟動數據連接，然後FTP服務器將命令和數據連接移至服務器上的隨機端口（數字大於1023）。通過從客戶端發起連接，允許通過防火牆的負擔由FTP服務器管理員承擔，他可以更好地設置一系列允許連接的端口。 \n 有關主動與被動FTP的更多信息，請訪問此 網站 。 \n Using FTP\xa0 使用FTP \n Accessing FTP public servers using the command line is not nearly as user-friendly as using a web browser. However, both methods are viable and in use in corporate networks. \n \n Open a web browser of choice \n Use this URL: ftp.funet.fi \n Click “pubs,” then “standards,” then “RFC” \n Search RFC 959 and access either the .txt or .pdf file (left-click) \n Search RFC 4217 and access either the .txt or .pdf file (left-click) \n If you actually needed the file you can right-click and save as. \n \n Now that you see the file structure, notice it is similar to navigating a local hard drive with the only difference being that you use the “/” (forward slash) instead of the “\\” (backslash) because you are accessing the folders through the Internet. \n Note: In this next step using the command-line interface, you will only be able to navigate the FTP server, and will not be able to transfer files, because ftp.exe does not support passive mode by default. You can use a command-line tool in a Linux Distro; or, in Windows, you can go to Passive-FTP.com and download the freeware. \n However, you can create a workaround by first allowing FTP through your firewall (be sure to put firewall restrictions back in place after the exercise), and then issuing the following commands after you enter the password: \n \n quote pasv \n \n 使用命令行訪問FTP公共服務器並不像使用Web瀏覽器那樣友好。但是，這兩種方法都是可行的，並且已在公司網絡中使用。 \n \n 打開選擇的網絡瀏覽器 \n 使用此URL：ftp.funet.fi \n 點擊“發布”，然後點擊“標準”，然後點擊“ RFC” \n 搜索RFC 959並訪問.txt或.pdf文件（單擊鼠標左鍵） \n 搜索RFC 4217並訪問.txt或.pdf文件（單擊鼠標左鍵） \n 如果您確實需要該文件，則可以右鍵單擊並另存為。 \n \n 現在您已經看到文件結構，請注意，它類似於瀏覽本地硬盤驅動器，唯一的區別是您使用“ /”（正斜杠）而不是“ \\”（反斜杠），因為您通過以下方式訪問文件夾互聯網。 \n 注意：在接下來的使用命令行界面的步驟中，您將只能瀏覽FTP服務器，並且將無法傳輸文件，因為ftp.exe默認情況下不支持被動模式。 您可以在Linux Distro中使用命令行工具。 或者，在Windows中，您可以轉到Passive-FTP.com並下載免費軟件。 \n 但是，您可以通過首先允許FTP通過防火牆（確保在練習後將防火牆限制放回原位），然後在輸入密碼後發出以下命令來創建解決方法： \n \n 引用pasv \n \n \n \n Image used under CC-BY license from Russell Burchill. \n \n Now the “dir, ls” (list directory contents), and “get” (download) commands will work. \n By default, the file will download to your user root at C:\\Windows\\Users\\** your user name ** or at the root of C:\\ (wherever your OS is installed). \n \n As a public FTP server set to passive mode, certain commands do not work and invoke the server to close the socket. If that happens, re-do your log on. \n \n Use the keyboard command \xa0 \xa0 + r and type ftp (from an administrative command line interface you can also type ftp). The prompt changes to ftp> \n \n 現在，“ dir，ls”（列出目錄內容）和“ get”（下載）命令將起作用。 \n 默認情況下，該文件將下載到用戶根目錄C：\\ Windows \\ Users \\ \xa0 **或 用戶名 **或C：\\根目錄（無論安裝了OS的位置）。 \n \n 將公共FTP服務器設置為被動模式後，某些命令將不起作用，並調用服務器以關閉套接字。 如果發生這種情況，請重新登錄。 \n \n 使用鍵盤命令 + r並鍵入ftp（在管理命令行界面中，您也可以鍵入ftp）。 提示符更改為ftp> \n \n Image used under CC-BY license from Russell Burchill. \n \n Type “help” and look at the commands. \n Type at the command prompt: open ftp.funet.fi. \n Follow the prompts to log on. \n Username: anonymous. \n Password: any generic e-mail (such as user@user.com). \n \n You get a welcome message and can now navigate through the directory structure you saw in the browser by typing the following commands: \n \n pwd — lists the current directory.\n \n \n cd — changes the directory. This may be in the form of:\n \n cd pub (refer to the URL path from the previous exercise), or \n cd/pub/standards/RFC/ \n \n \n \n \n 輸入“ help”並查看命令。 \n 在命令提示符下鍵入：打開ftp.funet.fi。 \n 按照提示進行登錄。 \n 用戶名：匿名。 \n 密碼：任何通用電子郵件（例如user@user.com）。 \n \n 您會收到一條歡迎消息，現在可以通過鍵入以下命令來瀏覽瀏覽器中看到的目錄結構： \n \n pwd-列出當前目錄。 \n \n \n cd —更改目錄。 可以採用以下形式： \n \n cd pub（請參閱上一練習中的URL路徑），或 \n cd / pub / standards / RFC / \n \n \n \n \n \n \n Image used under CC-BY license from Russell Burchill. \n \n \n \n Now if you are using the workaround, Mac, or Linux you can download a file using the “get” command: \n \n Image used under CC-BY license from Russell Burchill. \n \n \n \n 圖片由Russell Burchill根據CC-BY許可使用。 \n \n \n \n 現在，如果您使用的是變通方法，Mac或Linux，則可以使用“ get”命令下載文件： \n \n 圖片由Russell Burchill根據CC-BY許可使用。 \n \n Without the passive mode workaround, a third-party FTP client, Mac, or Linux this is as far as you can go. However, in the corporate environment you might be required to troubleshoot FTP on the local intranet, which would most likely be set to active FTP. Clearly, the need for command-line FTP service is fairly limited compared to using a browser. \n 如果沒有被動模式解決方法，則只能使用第三方FTP客戶端，Mac或Linux。 但是，在公司環境中，可能需要對本地Intranet上的FTP進行故障排除，這很可能會設置為活動FTP。 顯然，與使用瀏覽器相比，命令行FTP服務的需求非常有限。 \n \n \n', 'tags': '', 'url': 'FTP.html'}, {'title': 'SSL', 'text': 'Secure sockets layer (SSL) is a cryptographic protocol designed to secure network communications at the application layer. Netscape developed the original protocol in 1995 and SSL became deprecated and was replaced by transport layer security (TLS) in 2015. For more information about SSL, visit this \xa0 website . \n The most common place to see TLS/SSL in action is in your web browser. For example, most all web sites now default from http (port 80) to https (port 443) with TLS. It is a client-server model where the client initiates the request to connect and the server offers the secure protocol. \n 安全套接字層（SSL）是一種加密協議，旨在保護應用程序層的網絡通信安全。Netscape在1995年開發了原始協議，並且不贊成使用SSL，並在2015年由傳輸層安全性（TLS）取代。有關SSL的更多信息，請訪問此 網站 。 \n 實際使用TLS / SSL的最常見地方是您的Web瀏覽器。 例如，大多數網站現在默認使用TLS從http（端口80）更改為https（端口443）。 這是一種客戶端-服務器模型，其中客戶端發起連接請求，服務器提供安全協議。 \n \n EXAMPLE \n Try this: \n \n Type: http://facebook.com or http://google.com into the browser of your choice. Notice the new URL changed to https. \n \n \n Next, click on the padlock → connection. If you have an antivirus plug-in you might see the company’s certificate instead in browsers such as Internet Explorer. \n \n 試試這個： \n \n 在您選擇的瀏覽器中輸入：http://facebook.com或http://google.com。 請注意，新的URL更改為https。 \n \n \n 接下來，單擊掛鎖→連接。 如果您具有防病毒插件，則可能會在Internet Explorer之類的瀏覽器中看到該公司的證書。 \n \n \n Image used under CC-BY license from Russell Burchill. \n \n', 'tags': '', 'url': 'SSL.html'}, {'title': 'HW2', 'text': '', 'tags': '', 'url': 'HW2.html'}, {'title': 'HW3', 'text': '', 'tags': '', 'url': 'HW3.html'}, {'title': 'Exercise 34 練習34', 'text': '\n Birthday Json\xa0傑森生日\xa0 \xa0 \n \n This exercise is Part 2 of 4 of the birthday data exercise series. The other exercises are: \xa0 Part 1 , \xa0 Part 3 , and \xa0 Part 4 . \n In the \xa0 previous exercise \xa0 we created a dictionary of famous scientists’ birthdays. In this exercise, modify your program from \xa0 Part 1 \xa0 to load the birthday dictionary from a JSON file on disk, rather than having the dictionary defined in the program. \n Bonus : Ask the user for another scientist’s name and birthday to add to the dictionary, and update the JSON file you have on disk with the scientist’s name. If you run the program multiple times and keep adding new names, your JSON file should keep getting bigger and bigger. \n 此練習是生日數據練習系列4的第2部分。其他練習是： 第1部分 ， 第3 部分 和 第4部分 。 \n 在上 一個練習中， 我們創建了著名科學家生日字典。 在本練習中，請修改 第1部分中 的程序， 以從磁盤上的JSON文件加載生日字典，而不是在程序中定義字典。 \n 獎勵 ：向用戶詢問另一個科學家的名字和生日，以添加到詞典中，並使用科學家的名字更新磁盤上的JSON文件。 如果您多次運行該程序並繼續添加新名稱，那麼JSON文件應該會越來越大。 \n \n Discussion\xa0討論區 \n In a previous exercise we talked about \xa0 how to save information to a .txt file on disk , but in this exercise we are talking about writing a different kind of file format called JSON. \n The JSON file format was developed in the early 2000s as a standard for how web servers would pass data back and forth. It is still used for web server communication today, and it conveniently is also a way we can store dictionary-like data in a file on disk. The JSON format specifies a way to \xa0 serialize \xa0 (turn into a string) a dictionary or list, which then means that string can be written to disk or passed to another application. JSON is meant to store dictionary-like data both in a readable way for humans, and in a compact way that can be read by computers. Because it is a standard format, you can write JSON in one language and read JSON from another language to effectively pass information between the two programs or applications. You can read more about the history of JSON on \xa0 the wikipedia article . \n Here is an example of JSON: \n 在上一個練習中，我們討論瞭 如何將信息保存到磁盤上的.txt文件中 ，但是在本練習中，我們正在討論編寫另一種稱為JSON的文件格式。 \n JSON文件格式是在2000年代初期開發的，它是Web服務器如何來回傳遞數據的標準。 如今，它仍用於Web服務器通信，它也是我們可以將類似字典的數據存儲在磁盤上的文件中的一種便捷方式。 JSON格式指定了一種對 字典或列表 進行 序列化 （轉換為字符串）的方式，這意味著可以將字符串寫入磁盤或傳遞給另一個應用程序。 JSON旨在以人類可讀的方式以及計算機可以讀取的緊湊方式存儲類似字典的數據。 因為它是一種標準格式，所以您可以用一種語言編寫JSON並從另一種語言讀取JSON，以在兩個程序或應用程序之間有效地傳遞信息。 您可以在上閱讀有關JSON歷史的更多信息 維基百科文章 。 \n 這是JSON的示例： \n { \n     "name" :   "Michele" , \n     "shirt_color" :   "blue" , \n     "laptops" :   [ \n     { \n         "brand" :   "Lenovo" , \n         "operating_system" :   "Ubuntu" \n     }, \n     { \n         "brand" :   "Apple" , \n         "operating_system" :   "OSX" \n     } \n     ], \n     "has_a_dog" :   false , \n     "items_on_desk" :   [ "mug" ,   "pen" ,   "monitor" ] \n } \n Notice how you can mix dictionaries and lists. In this example the top-level container is a dictionary, with the keys \xa0 name , \xa0 shirt_color , \xa0 laptops , \xa0 has_a_dog , and \xa0 items_on_desk . The keys can be lists, strings, booleans, or other dictionaries. Usually you don’t write JSON by hand (but it is very readable so you easily could). One of my favorite tools to test whether you’ve written valid JSON is this free \xa0 JSON validator \xa0 - just paste your JSON in there and it tells you if it will be read by a program that understands JSON. \n There is a built-in Python library for reading and writing JSON files, so you don’t have to worry about how your dictionaries and lists are going to be turned into the right format! \n As long as the data you want to store is either a dictionary or a list of dictionaries, writing JSON is straightforward. First, import the \xa0 json \xa0 library \xa0 (no installation needed, it is built in to Python) and initialize some dictionary: \n 注意如何混合使用字典和列表。在這個例子中頂層容器是一個字典，與鍵 name ， shirt_color ， laptops ， has_a_dog ，和 items_on_desk 。鍵可以是列表，字符串，布爾值或其他字典。通常，您不需要手工編寫JSON（但它具有很高的可讀性，因此您可以輕鬆編寫）。這個免費的 JSON驗證程序 是我最喜歡的測試您是否已編寫有效JSON的 工具之一 -只需將JSON粘貼在其中，它就會告訴您是否會由理解JSON的程序讀取它。 \n 有一個內置的Python庫用於讀寫JSON文件，因此您不必擔心字典和列表將如何轉換為正確的格式！ \n 只要您要存儲的數據是字典還是詞典列表，編寫JSON就很簡單。 首先，導入 json 庫 （無需安裝，它內置在Python中）並初始化一些字典： \n \n import   json \n\n info_about_me   =   { \n     "name" :   "Michele" , \n     "has_a_dog" :   False \n } Then, to save your dictionary to disk you need to open a file and use the\xa0 json.dump() \xa0 method.  Remember to use the \xa0 w \xa0 flag when opening a file for writing: 然後，要將字典保存到磁盤，您需要打開一個文件並使用該 json.dump() 方法。 w 打開文件進行寫入時， 請記住使用 該 標誌： \n with   open ( "info.json" ,   "w" )   as   f : \n     json . dump ( info_about_me ,   f ) And you will have saved a file called\xa0 info.json \xa0 in the same directory as your Python program.  The dictionary \xa0 info_about_me \xa0 will be saved to disk, but the variable name will not be.  Basically, JSON won’t remember the name of the variable you saved your dictionary in.  If you open the file with a text editor (Notepad++, vim, emacs, Sublime Text, etc.), you  will just see: 您將 info.json 在與Python程序相同的目錄中 保存一個名為的文件 。 詞典 info_about_me 將保存到磁盤，但變量名 不會。 基本上，JSON不會記住保存字典的變量的名稱。如果使用文本編輯器（Notepad ++，vim，emacs，Sublime Text等） 打開文件，則只會看到： \n { \n     "name" :   "Michele" , \n     "has_a_dog" :   false \n } \n Alternatively, you can also manually create a JSON file and type JSON directly into it (passing it through \xa0 the JSON validator \xa0 of course!). Just save the file with the \xa0 .json \xa0 extension and copy the dictionary directly into the file. \n Now I can use the information about me that I saved to disk in another program (written in a completely different file) to do something like printing a message. When I saved the JSON file, the variable name of my dictionary was not saved with it, so when I load the JSON file I need to save it into a variable. I can use the same \xa0 json \xa0 library to do this: \n 另外，您也可以手動創建一個JSON文件，然後直接在其中鍵入JSON（當然，還要通過 JSON驗證器 ！）。只需保存帶有 .json 擴展名的文件，然後將字典直接複製到文件中即可。 \n 現在，我可以使用保存在另一個程序中的有關我的信息（以完全不同的文件編寫）來執行類似打印消息的操作。 當我保存JSON文件時，字典的變量名並未隨之保存，因此，當我加載JSON文件時，需要將其保存到變量中。 我可以使用相同的 json 庫來執行此操作： \n \n import   json \n \n with   open ( "info.json" ,   "r" )   as   f : \n     info   =   json . load ( f ) \n \n if   info [ "has_a_dog" ]: \n     print ( "{} has a dog" . format ( info [ "name" ])) \n else : \n     print ( "{} does not have a dog" . format ( info [ "name" ])) When this program runs, the output should be: \n 運行該程序時，輸出應為： \n Michele does not have a dog \n Notice how when I loaded the JSON file I used a different name than when I saved it - this is because the variable names don’t get saved together with the JSON data, so you do not have to use the same variable names to save and load JSON. \n Now that you know about JSON, you can use it to do a number of things: \n \n Save data to disk that can be shared by people and programs. \n Constantly update data that needs to be shared by re-saving and re-load to disk. \n Save data from a program that a human can read and manually check and fix errors. \n \n 請注意，加載JSON文件時使用的名稱與保存時使用的名稱不同-這是因為變量名稱不會與JSON數據一起保存，因此您不必使用相同的變量名稱進行保存和加載JSON。 \n 現在，您已經了解了JSON，可以使用它來做很多事情： \n \n 將數據保存到可以由人員和程序共享的磁盤。 \n 不斷更新需要通過重新保存並重新加載到磁盤的數據。 \n 保存人類可以讀取的程序中的數據，並手動檢查和修復錯誤。 \n \n \n \n \n \n \n \n \n Solutions\xa0解決方案 \n Sample solution 範例解答 \n Here is one reader’s solution to the exercise: \n 這是該練習的一個讀者解決方案： \n import json\n\nbirthday = {}\nwith open(\'birthdays.json\', \'r\') as f:\n          birthday = json.load(f)\n\ndef add_entry():\n    name = input(\'Who do you want to add to the Birthday Dictionnary?\\n\').title()\n    date = input(\'When is {} born?\\n\'.format(name))\n    birthday[name] = date\n    with open(\'birthdays.json\', \'w\') as f:\n        json.dump(birthday, f)\n    print(\'{} was added to my birthday list\\n\'.format(name))\n\ndef find_date():\n    name = input("who\'s birthday do you want to know?\\n").title()\n    try :\n        if birthday[name]:\n            print(\'{} is born on {}\\n\'.format(name, birthday[name]))\n    except KeyError:\n        print(\'{} is not in the list\\n\'.format(name))\n\ndef list_entries():\n    print(\'The current entries in my birthday list are:\\n============================================\')\n    for key in birthday:\n        print(key.ljust(31), \':\', birthday[key])\n    print()\n\nwhile True:\n    what_next = input(\'What do you want to do next? you can: Add, Find, List, Quit\\n\').capitalize()\n    if what_next == \'Quit\':\n        print(\'Good Bye\')\n        raise SystemExit(0)\n    elif what_next == \'Add\':\n        add_entry()\n    elif what_next == \'Find\':\n        find_date()\n    elif what_next == \'List\':\n        list_entries() \n \n', 'tags': '', 'url': 'Exercise 34 練習34.html'}, {'title': 'Exercise 24\xa0 練習24', 'text': '\n Draw A Game Board \xa0 \xa0 \n 畫遊戲板\xa0 \n This exercise is Part 1 of 4 of the Tic Tac Toe exercise series. The other exercises are: \xa0 Part 2 , \xa0 Part 3 , and \xa0 Part 4 . \n Time for some fake graphics! Let’s say we want to draw game boards that look like this: \n 此練習是Tic Tac Toe練習系列4的第1部分。其他練習是： 第2部分 ， 第3 部分 和 第4部分 。 \n 是時候購買一些假圖形了！ 假設我們要繪製如下游戲板： \n   ---   ---   ---  \n |     |     |     |  \n  ---   ---   ---   \n |     |     |     |  \n  ---   ---   ---   \n |     |     |     |  \n  ---   ---   ---   \n This one is 3x3 (like in tic tac toe). Obviously, they come in many other sizes (8x8 for chess, 19x19 for Go, and many more). \n Ask the user what size game board they want to draw, and draw it for them to the screen using Python’s \xa0 print \xa0 statement. \n Remember that in Python 3, printing to the screen is accomplished by \n \n    print ( "Thing to show on screen" ) \n \n Hint: this requires some use of functions, as were discussed \xa0 previously on this blog \xa0 and \xa0 elsewhere on the Internet, like this TutorialsPoint link . \n 這是3x3（就像井字遊戲一樣）。顯然，它們有許多其他尺寸（國際象棋為8x8，圍棋為19x19等）。 \n 詢問用戶他們要繪製什麼尺寸的遊戲板，並使用Python的 print 語句 將其繪製到屏幕上 。 \n 請記住，在Python 3中，打印到屏幕是通過以下方式完成的： \n \n    print ( "Thing to show on screen" ) \n \n 提示：這需要某種功能的使用，如 本博客之前 和 Internet上其他地方所討論的，例如TutorialsPoint鏈接 。 \n \n Topics and links for more information \n 主題和鏈接，以獲取更多信息 \n The main topic of this exercise is functions. They are tricky, and deserve lots of practice and thought. Here are a few links in case you want some more reading. \n \n Functions on TutorialsPoint \n Hands-on Python, by Loyola University \n Learn Python the Hard Way \n ZetCode \n \n There are hundreds more out there - read and practice away! \n 本練習的主要主題是功能。它們很棘手，值得大量實踐和思考。這裡有一些鏈接，以備您需要更多閱讀。 \n \n TutorialsPoint上的功能 \n Loyola University的動手Python \n 艱苦學習Python \n 郵遞區號 \n \n 那裡還有數百個-閱讀和練習吧！ \n \n Solutions\xa0解決方案 \n Sample solution \n Let’s break this task into pieces and use Python 3. \n First, the user needs to a numbers that represent the size of the game board (assuming the game board will be n by n). ( Bonus exercise: extend the following code to make the game board not square. ). The following snippet assumes that the person entered a number and doesn’t do any kind of error checking - for now, that’s OK. \n \n    board_size   =   int ( input ( "What size of game board? " )) \n \n Then, we need to draw each row of the game board. Each row consists of horizontal pieces ( --- ) and vertical pieces ( | ). Each of these shows up in a pattern, so we can rely on for loops to help with the rendering. \n To print a single row, we want to do something like this: \n \n    print ( " --- "   *   board_size ) \n \n To print the vertical parts of the row, we want something like this, because we don’t care about trailing whitespace, and because we want one more vertical line than the size of the board: \n \n    print ( "|   "   *   ( board_size   +   1 )) \n \n For a board of size \xa0 board_size \xa0 we want to print that many horizontal pieces and vertical pieces, plus an extra horizontal piece for the bottom. Let’s use functions for this entire operation, since we might want to change the style on the game boards for later use. All together, the program will look like this: \n \n    def   print_horiz_line (): \n     print ( " --- "   *   board_size ) \n\n   def   print_vert_line (): \n     print ( "|   "   *   ( board_size   +   1 )) \n\n   if   __name__   ==   "__main__" : \n     board_size   =   int ( input ( "What size of game board? " )) \n\n     for   index   in   range ( board_size ): \n       print_horiz_line () \n       print_vert_line () \n     print   horiz_line () \n \n This way, if we ever decide to change the design of the game board by making it bigger, it will be easy to do! All we need to do is change the \xa0 print_horiz_line() \xa0 and \xa0 print_vert_line() \xa0 functions, and we’re all set! \n 範例解答 \n 讓我們將這項任務分解成幾個部分並使用Python 3。 \n 首先，用戶需要一個代表遊戲板尺寸的數字（假設遊戲板為n×n）。 （ 額外的練習：擴展以下代碼以使遊戲板不方形。 ）。 以下代碼段假定此人輸入了一個數字，並且沒有進行任何類型的錯誤檢查-暫時可以。 \n \n    board_size   =   int ( input ( "What size of game board? " )) \n \n 然後，我們需要繪製遊戲板的每一行。 每行由水平部分（ --- ）和垂直部分（ | ）組成。 每一個都以一種模式顯示，因此我們可以依靠for循環來幫助進行渲染。 \n 要打印一行，我們想做這樣的事情： \n \n    print ( " --- "   *   board_size ) \n \n 要打印行的垂直部分，我們需要這樣的東西，因為我們不在乎尾隨空格，並且因為我們想要的垂直線比板子的尺寸還要多： \n \n    print ( "|   "   *   ( board_size   +   1 )) \n \n 對於大小為 board_size 的板子， 我們要打印許多水平件和垂直件，並在底部再增加一個水平件。 讓我們在整個操作過程中使用函數，因為我們可能想更改遊戲板上的樣式以備後用。 總之，該程序將如下所示： \n \n    def   print_horiz_line (): \n     print ( " --- "   *   board_size ) \n \n   def   print_vert_line (): \n     print ( "|   "   *   ( board_size   +   1 )) \n \n   if   __name__   ==   "__main__" : \n     board_size   =   int ( input ( "What size of game board? " )) \n \n     for   index   in   range ( board_size ): \n       print_horiz_line () \n       print_vert_line () \n     print   horiz_line () \n \n 這樣，如果我們決定通過擴大遊戲板的設計來改變它的設計，那將很容易做到！ 我們需要做的就是更改 print_horiz_line() 和 print_vert_line() 功能，並且一切就緒！ \n \n A few user solutions not using functions \n 一些不使用功能的用戶解決方案 \n This one is pretty simple, and it is specific to the 3x3 board above. There is no way to change the size. Additionally, writing out the\xa0 a \xa0and\xa0 b \xa0lists in the print statement are tedious and can be improved with a list comprehension or for loop. \n 這很簡單，它特定於上面的3x3板。無法更改大小。此外，在打印語句中寫出 a and b 列表很繁瑣，可以通過列表理解或for循環加以改進。 \n a = \'---\'.join(\'    \')\nb = \'   \'.join(\'||||\')\nprint(\'\\n\'.join((a, b, a, b, a, b, a))) The author chose to use a\xa0 while \xa0 loop instead of a \xa0 for \xa0 loop to do the printing, which  was an interesting choice. But it works! 作者選擇使用 while 循環而不是 for 循環進行打印，這是一個有趣的選擇。 但這有效！ \n def drawboard(kamal):\n    kamal = int(kamal)\n    i = 0\n    ho = "--- "\n    ve = "|   "\n    ho = ho * kamal\n    ve = ve * (kamal+1)\n    while i < kamal+1:\n        print ho\n        if not (i == kamal):\n            print ve\n        i += 1\n \n \n', 'tags': '', 'url': 'Exercise 24\xa0 練習24.html'}, {'title': 'Exercise 28\xa0 練習28', 'text': "Implement a function that takes as input three variables, and returns the largest of the three. Do this without using the Python max() function! \n The goal of this exercise is to think about some internals that Python normally takes care of for us. All you need is some variables and if statements! \n 實現一個函數，將三個變量作為輸入，並返回三個變量中的最大值。 無需使用Python max（）函數即可執行此操作！ \n 本練習的目的是考慮Python通常為我們處理的一些內部組件。 您只需要一些變量和if語句！ \n solution 解決方案 \n Sample solutions \n There are many ways to answer this question, ranging from simple to complex. Here are a few reader-submitted answers! \n This first example solution uses a series of if statements and comparisons to find the largest of 3 elements. \n 有許多方法可以回答此問題，從簡單到復雜。 這是讀者提交的一些答案！ \n 第一個示例解決方案使用一系列if語句和比較來查找3個元素中的最大元素。 \n def max_of_three(a,b,c):\n     max_3=0\n     if a>b:\n         #max_3=a\n         if a>c:\n             max_3=c\n         else:\n             max_3=a\n     else:\n          if b>c:\n             max_3=b\n          else:\n             max_3=c\n     return max_3 Another solution is a little bit less verbose, taking 3 numbers as an input, making them into  a list, sorting them, and then reading off the largest element. This last solution uses a more compact series of if statement comparisons to cover all cases  of 3 elements. 另一個解決方案是稍微冗長一些，將3個數字作為輸入，將它們放入列表，對它們進行排序，然後讀取最大的元素。 最後一個解決方案使用一系列更緊湊的if語句比較來涵蓋3個元素的所有情況。 \n #!/usr/bin/env python\nimport sys\n\nif len(sys.argv) < 4:\n    print 'Usage <value1> <value2> <value3>'\n    sys.exit ( 1 )\n    \narg1 = sys.argv[1]\narg2 = sys.argv[2]\narg3 = sys.argv[3]\ndef maxfunction(a,b,c):\n\tif (a > b) and (a > c):\n\t    print 'Max value is :',a\n        elif (b > a) and (b > c):\n            print 'Max value is :',b\n        elif (c > a) and (c > b):\n            print 'Max value is :',c\n            \nmaxfunction(arg1,arg2,arg3) \n", 'tags': '', 'url': 'Exercise 28\xa0 練習28.html'}]};